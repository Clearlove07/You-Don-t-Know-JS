你不知道的Javasceipt(中卷)
#  第五章 语法
## 5.1  语法和表达
声明语句,声明了变量。示例:
```sh
var a = 3 * 6;
```
赋值表达式。示例:
```sh
a = 3 * 6;
```
### 5.1.1 语句的结果值
> 很多人都不知道，语句是有一个结果值(undefined也算)。但是我们在代码中无法获取这个结果值。

例如在控制台输入:
```sh
var a = 42;
// undefined 
```
得到的结果是undefined，而非42;
又如代码块`{}`:
```sh
var b;

if(true) {
    b = 4 + 38;
}
// 42 
```
> 换句话说, 代码块的结果值如同一个`隐式的返回`, 即返回最后一个语句的结果值。

但下面这样的代码是无法执行的:
```sh
var a, b;

a = if(true) {
    b = 4 + 38;
}
```
> 因为语法不允许我们获取语句中的结果值并将其赋值给一个变量(至少目前不行)。

那应该怎么获取语句的结果值呢？可以使用万恶的eval(..)来获得结果:
```sh
var a, b;

a = eval('if(true) { b = 4 + 38; }');

a; //42
```
这并不是好办法，但确实管用。`不过再次强调:不要使用eval(..)!!`

ES7规范里面有一项'do表达式'(do expression) 提案，类似下面这样:
```sh
var a, b;

a = do {
    if (true) {
        b = 4 + 38;
    }
}

a; //42
```
其目的是为了将语句当作表达式来处理(语句中可以包含其他语句)，从而不需要将语句封装成函数再调用return来返回值。

### 5.1.2 表达式的副作用
最常见的有副作用(也可能没有)的表达式是函数调用:
```sh
function(){
    a = a + 1;
}

var a = 1; 
foo(); // 结果值为: undefined。副作用: a的值被改变；
```

其他一些表达式也有副作用,比如:
```sh
var a = 42;
var b = a++;

a; // 43
b; // 42
```

常有人会误以为用`括号( )`将a++的副作用封装起来，例如:
```sh
var a = 42;
var b = (a++);

a; // 43
b; // 42
```
事实并非如此。( )本身不是一个封装表达式，不会在表达式a++产生副作用之后执行。

但也不是没有办法，可以使用`,`语句系列逗号运算符将多个独立的表达式语句串联成一个语句:
```sh
var a = 42, b;
b = (a++, a);

a; // 43
b; // 43
```
a++, a中第二个表达式a是在a++之后执行,所以结果为43，然后赋值给b。

### 5.1.3 上下文规则
(1) 大括号

用大括号定义对象常量:
```sh
// 假定已经定义bar()

var a = {
    foo: bar()
};
```
{..} 被赋值给a, 因而它是一个对象常量。

(2) 标签

Javascript不支持goto,然而Javascript通过标签跳转能够实现goto的部分功能。continue和break语句都可以带一个标签，因此能够像goto那样进行跳转。列如:
```sh
foo: for(var i=0; i<4; i++){
    for(var j=0; j<4; j++){
        // 如果j和i相等，继续外层循环
        if(j == i){
            // 跳转到下一个循环
            continue foo; 
        }

        // 跳过奇数结果
        if((j * i) % 2 = 1){
        	// 继续内层循环(没有标签的)
        	continue;
        }

        console.log(i, j);
    }
}
// 1 0
// 2 0
// 2 1
// 3 0
// 3 2
```
> continue foo并不是指'跳转到标签所在的位置继续执行'，而且'执行foo循环的下一个循环'。所以这里的foo 并非goto。

带标签的循环跳转一个更大的用处在于，和break一起使用可以实现从内层循环跳转到外层循环。例如:
```sh
// 标签为foo
foo: for(var i=0; i<4; i++){
    for(var j=0; j<4; j++){
        if((i * j) >= 3){
            console.log('stoping!', i, j);
        }

        console.log(i, j);
    }
}

// 0 0 
// 0 1
// 0 2
// 0 3
// 1 0
// 1 2
// stoping! 1 3
```
> break foo不是指'跳转到标签foo所在的位置继续继续执行'，而是'跳出标签foo所在循环/代码块，继续执行后面的代码'。因此它并非传统意义上的goto。

(3) 对象解构
